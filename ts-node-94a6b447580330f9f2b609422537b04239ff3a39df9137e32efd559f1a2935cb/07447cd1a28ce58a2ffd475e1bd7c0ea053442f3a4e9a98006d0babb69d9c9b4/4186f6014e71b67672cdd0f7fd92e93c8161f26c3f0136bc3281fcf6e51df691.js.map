{"version":3,"file":"/mnt/c/basidia/material2/tools/gulp/tasks/unit-test.ts","sources":["/mnt/c/basidia/material2/tools/gulp/tasks/unit-test.ts"],"names":[],"mappings":";AAAA,6BAA0B;AAC1B,6BAAiC;AACjC,sDAAkD;AAClD,0CAA0D;AAC1D,qDAAkD;AAElD,6DAA6D;AAC7D,IAAM,WAAW,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;AAE5C,IAAM,YAAY,GAAG,WAAI,CAAC,0BAAc,EAAE,qBAAqB,CAAC,CAAC;AAEjE,wEAAwE;AACxE,WAAI,CAAC,2BAA2B,EAAE,cAAM,OAAA,mBAAG,CAAC,YAAY,EAAE,EAAC,QAAQ,EAAE,0BAAc,EAAC,CAAC,EAA7C,CAA6C,CAAC,CAAC;AAEvF,qDAAqD;AACrD,WAAI,CAAC,aAAa,EAAE,2BAAY,CAC9B,OAAO,EACP,2BAA2B,EAC3B,gBAAgB,EAChB,uBAAuB,CACxB,CAAC,CAAC;AAEH;;;GAGG;AACH,WAAI,CAAC,iBAAiB,EAAE,CAAC,aAAa,CAAC,EAAE,UAAC,IAAgB;IACxD,kFAAkF;IAClF,IAAI,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;IAE7B,IAAI,KAAK,CAAC,MAAM,CAAC;QACf,UAAU,EAAE,WAAI,CAAC,wBAAY,EAAE,oBAAoB,CAAC;QACpD,SAAS,EAAE,IAAI;KAChB,EAAE,UAAC,QAAgB;QAClB,wEAAwE;QACxE,oEAAoE;QACpE,QAAQ,KAAK,CAAC,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACnD,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;AACb,CAAC,CAAC,CAAC;AAEH;;;;;;;;;;GAUG;AACH,WAAI,CAAC,MAAM,EAAE,CAAC,aAAa,CAAC,EAAE;IAC5B,IAAI,WAAW,GAAG,WAAI,CAAC,0BAAc,EAAE,MAAM,CAAC,CAAC;IAC/C,kFAAkF;IAClF,IAAI,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;IAE7B,oFAAoF;IACpF,IAAI,MAAM,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC;QAC5B,UAAU,EAAE,WAAI,CAAC,wBAAY,EAAE,oBAAoB,CAAC;QACpD,SAAS,EAAE,KAAK;QAChB,SAAS,EAAE,KAAK;KACjB,CAAC,CAAC;IAEH,wDAAwD;IACxD,gEAAgE;IAChE,IAAI,QAAQ,GAAG,UAAC,GAAW;QACzB,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,YAAY,EAAE,CAAC,IAAI,CAAC,cAAM,OAAA,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,QAAQ,EAAE,EAA3C,CAA2C,CAAC,CAAC;QAChF,CAAC;IACH,CAAC,CAAC;IAEF,6EAA6E;IAC7E,MAAM,CAAC,KAAK,EAAE,CAAC;IACf,MAAM,CAAC,EAAE,CAAC,kBAAkB,EAAE,cAAM,OAAA,QAAQ,EAAE,EAAV,CAAU,CAAC,CAAC;IAEhD,4EAA4E;IAC5E,YAAK,CAAC,WAAW,GAAG,kBAAkB,EAAE,cAAM,OAAA,WAAW,CAAC,aAAa,EAAE,QAAQ,CAAC,EAApC,CAAoC,CAAC,CAAC;AACtF,CAAC,CAAC,CAAC","sourcesContent":["import {join} from 'path';\nimport {task, watch} from 'gulp';\nimport {main as ngc} from '@angular/compiler-cli';\nimport {PROJECT_ROOT, COMPONENTS_DIR} from '../constants';\nimport {sequenceTask} from '../util/task_helpers';\n\n// There are no type definitions available for these imports.\nconst runSequence = require('run-sequence');\n\nconst tsconfigFile = join(COMPONENTS_DIR, 'tsconfig-specs.json');\n\n/** Builds the library with a tsconfig file that includes spec files. */\ntask(':test:build:library-specs', () => ngc(tsconfigFile, {basePath: COMPONENTS_DIR}));\n\n/** Builds everything that is necessary for karma. */\ntask(':test:build', sequenceTask(\n  'clean',\n  ':test:build:library-specs',\n  'library:assets',\n  'library:assets:inline',\n));\n\n/**\n * Runs the unit tests. Does not watch for changes.\n * This task should be used when running tests on the CI server.\n */\ntask('test:single-run', [':test:build'], (done: () => void) => {\n  // Load karma not outside. Karma pollutes Promise with a different implementation.\n  let karma = require('karma');\n\n  new karma.Server({\n    configFile: join(PROJECT_ROOT, 'test/karma.conf.js'),\n    singleRun: true\n  }, (exitCode: number) => {\n    // Immediately exit the process if Karma reported errors, because due to\n    // potential still running tunnel-browsers gulp won't exit properly.\n    exitCode === 0 ? done() : process.exit(exitCode);\n  }).start();\n});\n\n/**\n * [Watch task] Runs the unit tests, rebuilding and re-testing when sources change.\n * Does not inline resources. Note that this doesn't use Karma's built-in file\n * watching. Due to the way our build process is set up, Karma ends up firing\n * it's change detection for every file that is written to disk, which causes\n * it to run tests multiple time and makes it hard to follow the console output.\n * This approach runs the Karma server and then depends on the Gulp API to tell\n * Karma when to run the tests.\n *\n * This task should be used when running unit tests locally.\n */\ntask('test', [':test:build'], () => {\n  let patternRoot = join(COMPONENTS_DIR, '**/*');\n  // Load karma not outside. Karma pollutes Promise with a different implementation.\n  let karma = require('karma');\n\n  // Configure the Karma server and override the autoWatch and singleRun just in case.\n  let server = new karma.Server({\n    configFile: join(PROJECT_ROOT, 'test/karma.conf.js'),\n    autoWatch: false,\n    singleRun: false\n  });\n\n  // Refreshes Karma's file list and schedules a test run.\n  // Tests will only run if TypeScript compilation was successful.\n  let runTests = (err?: Error) => {\n    if (!err) {\n      server.refreshFiles().then(() => server._injector.get('executor').schedule());\n    }\n  };\n\n  // Boot up the test server and run the tests whenever a new browser connects.\n  server.start();\n  server.on('browser_register', () => runTests());\n\n  // Whenever a file change has been recognized, rebuild and re-run the tests.\n  watch(patternRoot + '.+(ts|scss|html)', () => runSequence(':test:build', runTests));\n});\n"]}